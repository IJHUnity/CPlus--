//#include <iostream>
//using namespace std;
////함수 : 사용자가 특정 하나의 기능을 수행하기 위해
////       기능들을 모아놓은 명령 집합체
////       만들어진 함수는 사용자가 필요한 만큼 호출해서 사용할 수 있습니다.
//
////C++의 함수 사용
////함수의 형태
////반환할자료형 함수명(매개변수)
////{
////	실행할 명령문;
////	return 반환할 값;
////}
////1. 반환할 자료형 : 함수의 형태를 표현할 수 있으며, 해당 형태에 맞는 return 값을 가지고 있어야 합니다.
////					단 void의 경우는 return 값을 따로 가지지 않습니다.
////2. 매개변수 :		사용자가 함수를 호출할 때, 전달해줄 값을 받기 위한 변수
////					사용자가 함수 호출을 위해 전달해주는 값은 인자(Argment)라고 부릅니다.
////3. return :		함수를 종료하는 기능을 가진 제어문입니다. return 다음에 형태에 맞는 값을 적으면 함수를
////					호출한 위치에 해당 값이 전달됩니다.
//
////함수를 사용하는 이유
////1. 함수를 통해 사용자가 무슨 작업을 할지 이해하기가 쉽습니다.(기능이 모여 있기 때문)
////2. 함수를 설계하면 중복적인 코드 작업 없이 해당 함수를 호출해 편하게 사용할 수 있습니다.(중복 설계 방지)
////3. 함수를 통해 코드를 분할하고, 기능에 대한 유지보수 시 함수를 고치는 것으로 해결 가능(수정이 쉬워짐)
////4. 여러 사람과 나누어 작업하는 프로젝트 단위의 코드 설계 시 특정 기능에 대한 모듈화 관리 가능
//
//
//int bytwo(int value) // 함수의 이름과 매개변수의 이름은 자유롭게 작성할 수 있습니다.
//{
//	return value * 2; //value를 받아서 value를 2배한 값을 [(★★★)호출한 위치에] 전달합니다.
//}
//void bythree(int value)
//{
//	value = value * 3; //value를 3배 합니다.
//}
//void byfour(int& value)
//{
//	value = value * 4;//value를 4배 합니다.
//}
//int main()
//{
//	int main_value = 10;
//	cout << main_value << endl;
//	main_value = bytwo(main_value); //형태가 같기 때문에 = 가능
//	cout << main_value << endl;
//	bythree(main_value);//void의 경우는 그냥 호출만 진행 
//	cout << main_value << endl;
//
//	//1. void로 설계된 함수는 일반 함수라고 부르겠습니다.(호출만 진행해서 작업 종료)
//	//2. int처럼 자료형으로 설계된 함수를 return 함수라고 부르겠습니다.(값에 대한 전달을 위해 대입이 들어감.)
//	//3. 매개변수는 함수 내에서 만들어지는 변수이고, 함수가 종료되면 삭제되며 전달받은 값을 복사해서 가지고 있습니다.
//	//   =>매개변수는 전달받은 원본이 아니다.
//
//	int& ref_value = main_value;
//	//자료형&가 붙은 형태를 참조자(reference)라고 부르겠습니다. (C++의 문법)
//	//이름 그대로 참조자는 변수에 대한 참조를 진행할 수 있습니다.(자신의 변수를 대신할 또 하나의 이름, 별명같은 개념)
//	//참조자를 활용하면 실제 값에 대한 접근을 쉽게 사용할 수 있습니다.
//	byfour(ref_value);
//	cout << "메인 값 " << main_value << endl;
//	cout << "참조 값 " << ref_value << endl;
//	
//	//참조자의 경우는 C언어의 포인터처럼 실제 값에 대한 접근을 할 때 사용할 수 있습니다.
//	//참조자는 특정 값에 대한 참조를 진행하며, 따라서 값이 반드시 존재해야 합니다.(선언만 하는 것은 불가능하다.)
//	//포인터에서 현재 가리키는 값이 없음을 나타내는 NULL도 참조자는 사용할 수 없습니다.
//	//참조자는 포인터가 무분별하게 값을 가리키어 오류가 발생할 수 있는 부분이 개선된 문법으로
//	//안전성이 매우 높아 특별한 상황(NULL 값 표현)을 제외한 모든 상황에 참조자를 사용하는 것을 권장합니다.
//	return 0;
//}